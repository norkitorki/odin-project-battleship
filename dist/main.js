/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./lib/battleship.js":
/*!***************************!*\
  !*** ./lib/battleship.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Battleship: () => (/* binding */ Battleship)\n/* harmony export */ });\n/* harmony import */ var _gameboardDisplay__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gameboardDisplay */ \"./lib/gameboardDisplay.js\");\n/* harmony import */ var _ship__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ship */ \"./lib/ship.js\");\n\n\n\nconst Battleship = (player, opponent, computer) => {\n  const obj = { player, opponent, computer };\n\n  obj.gameInProgress = false;\n  obj.shipPlacementDirection = 'h';\n\n  const callbacks = {\n    keyboard: {},\n    placementError: [],\n    preReset: [],\n    preShipPlacement: [],\n    preShipsPlacement: [],\n    postShipsPlacement: [],\n    preAttack: [],\n    postAttack: [],\n    preGame: [],\n    postGame: [],\n  };\n\n  const lastPlayerCoordinates = {};\n\n  let inactivePlayer = player;\n  let inactiveOpponent = opponent;\n  let playerPlacement = {};\n  let computerInPlay = false;\n\n  window.addEventListener('keydown', (ev) => {\n    const events = callbacks.keyboard[ev.code];\n    if (events) events.forEach((cb) => cb.call(null));\n  });\n\n  const createBoardContainer = () => {\n    const gameContainer = document.createElement('div');\n    const targetHeader = document.createElement('h2');\n    const targetContainer = document.createElement('div');\n    const fleetHeader = document.createElement('h2');\n    const fleetContainer = document.createElement('div');\n\n    targetHeader.textContent = 'Target Board';\n    fleetHeader.textContent = 'Fleet Board';\n\n    gameContainer.classList.add('playerContainer');\n    targetContainer.classList.add('targetBoard');\n    fleetContainer.classList.add('fleetBoard');\n\n    [\n      [targetHeader, targetContainer],\n      [fleetHeader, fleetContainer],\n    ].forEach((arr) => {\n      const [header, container] = arr;\n      header.classList.add('boardHeader');\n      const wrapper = document.createElement('section');\n      wrapper.appendChild(header);\n      wrapper.appendChild(container);\n      gameContainer.appendChild(wrapper);\n    });\n\n    return gameContainer;\n  };\n\n  const createPlayerComponents = () => {\n    const players = [player, opponent];\n    if (computer) players.push(computer);\n\n    players.forEach((p) => {\n      p.targetDisplay = (0,_gameboardDisplay__WEBPACK_IMPORTED_MODULE_0__.GameboardDisplay)(10, 10);\n      p.fleetDisplay = (0,_gameboardDisplay__WEBPACK_IMPORTED_MODULE_0__.GameboardDisplay)(10, 10);\n\n      p.container = createBoardContainer();\n      p.targetDisplay.renderBoard(p.container.querySelector('.targetBoard'));\n      p.fleetDisplay.renderBoard(p.container.querySelector('.fleetBoard'));\n    });\n  };\n\n  const callCallbacks = (eventType, callbackArgs = []) => {\n    if (callbacks[eventType])\n      callbacks[eventType].forEach((cb) => cb.apply(null, callbackArgs));\n  };\n\n  const clearBoards = (gamePlayer) => {\n    gamePlayer.gameboard.clear();\n    [gamePlayer.targetDisplay, gamePlayer.fleetDisplay].forEach((display) => {\n      display.clear(true);\n    });\n  };\n\n  const displayPlacedShips = (gamePlayer, coordinates, random = false) => {\n    const targetDisplay = gamePlayer.targetDisplay;\n    const fleetDisplay = gamePlayer.fleetDisplay;\n    let displays = [targetDisplay, fleetDisplay];\n    if (random) displays = [fleetDisplay];\n\n    coordinates.forEach((arr) => {\n      const [row, col] = arr;\n      displays.forEach((display) => {\n        display.updateField(row, col, 'pegTemplate', 'whitePeg');\n      });\n    });\n  };\n\n  const postShipsPlacement = (gamePlayer, opponentPlayer) => {\n    if (!gamePlayer.computerPlayer) gamePlayer.targetDisplay.clear(true);\n    callCallbacks('postShipsPlacement', [gamePlayer, opponentPlayer]);\n    playerPlacement.resolve();\n  };\n\n  const randomShipPlacement = (gamePlayer, opponentPlayer) => {\n    playerPlacement.ships.splice(0, gamePlayer.gameboard.shipCount);\n    playerPlacement.ships.forEach((ship) => {\n      const coordinates = gamePlayer.randomShipPlacement(ship);\n      displayPlacedShips(gamePlayer, coordinates, true);\n    });\n    return postShipsPlacement(gamePlayer, opponentPlayer);\n  };\n\n  const playerShipPlacement = (gamePlayer, opponentPlayer) => {\n    callCallbacks('preShipsPlacement', [gamePlayer, opponentPlayer]);\n\n    const ships = [2, 3, 3, 4, 5].map((n) => (0,_ship__WEBPACK_IMPORTED_MODULE_1__.Ship)(n));\n    const display = gamePlayer.targetDisplay;\n\n    let coordinates = [];\n    let shipIndex = 0;\n    let ship = ships[shipIndex];\n\n    const predictShipPlacement = (row, col) => {\n      coordinates = [];\n      display.removeHighlights();\n\n      for (let i = 0; i < ship.length; i++) {\n        let coords =\n          obj.shipPlacementDirection === 'h' ? [row, col + i] : [row + i, col];\n        display.highlightField.apply(null, coords);\n        coordinates.push(coords);\n      }\n    };\n\n    callCallbacks('preShipPlacement', [player, opponent, ship]);\n\n    return new Promise((resolve) => {\n      playerPlacement = { player: gamePlayer, ships, resolve };\n\n      if (gamePlayer.computerPlayer) {\n        return randomShipPlacement(gamePlayer, opponentPlayer);\n      } else {\n        display.addCallback('mouseover', 'showPlacement', predictShipPlacement);\n        display.addCallback('focusin', 'showPlacement', predictShipPlacement);\n        display.addCallback('click', 'placeShip', () => {\n          try {\n            gamePlayer.gameboard.placeShip(coordinates, ship);\n            displayPlacedShips(gamePlayer, coordinates);\n            ship = ships[++shipIndex];\n            if (shipIndex >= ships.length) {\n              return postShipsPlacement(gamePlayer, opponentPlayer);\n            } else {\n              coordinates = [];\n              callCallbacks('preShipPlacement', [player, opponent, ship]);\n            }\n          } catch (error) {\n            callCallbacks('placementError', [error]);\n            console.error(error.message);\n          }\n        });\n      }\n    });\n  };\n\n  const focusLastField = (gamePlayer) => {\n    const field = lastPlayerCoordinates[gamePlayer.name];\n    const targetBoard = gamePlayer.container.querySelector('.targetBoard');\n    if (field && targetBoard)\n      targetBoard.querySelector(`[data-field=\"${field}\"]`).focus();\n  };\n\n  const playerAttack = () => {\n    return new Promise((resolve, _) => {\n      if (player.computerPlayer) {\n        resolve(player.attack(opponent));\n      } else {\n        const targetDisplay = player.targetDisplay;\n        focusLastField(player, targetDisplay);\n\n        targetDisplay.addCallback('click', 'userAttack', (row, col) => {\n          if (player.gameboard.targetBoard[[row, col]] === undefined) {\n            const attackResult = player.attack(opponent, row, col);\n            lastPlayerCoordinates[player.name] = `${row}${col}`;\n            targetDisplay.removeCallback('click', 'userAttack');\n            resolve({ coordinates: [row, col], attackResult });\n          }\n        });\n      }\n    });\n  };\n\n  const updateField = (display, coordinates, pegClazz) => {\n    const [row, col] = coordinates;\n    if (pegClazz) display.updateField(row, col, 'pegTemplate', pegClazz);\n  };\n\n  const updateSunkenShip = (coordinates) => {\n    const fields = opponent.gameboard.shipPlacements.find((arr) => {\n      return arr.find((c) => c.join() === coordinates.join());\n    });\n    fields.forEach((arr) => updateField(player.targetDisplay, arr, 'cyanPeg'));\n  };\n\n  const updateDisplays = (attack) => {\n    const attackResult = attack.attackResult;\n\n    if (typeof attackResult === 'object' && attackResult.isSunk()) {\n      updateSunkenShip(attack.coordinates);\n    } else {\n      const targetPeg = attackResult ? 'whitePeg' : 'redPeg';\n      updateField(player.targetDisplay, attack.coordinates, targetPeg);\n    }\n\n    const fleetPeg = attackResult ? 'redPeg' : null;\n    updateField(opponent.fleetDisplay, attack.coordinates, fleetPeg);\n  };\n\n  const endGame = () => {\n    obj.gameInProgress = false;\n    callCallbacks('postGame', [player, opponent]);\n    return player;\n  };\n\n  const swapPlayers = () => {\n    [player, opponent] = [opponent, player];\n    [obj.player, obj.opponent] = [obj.opponent, obj.player];\n  };\n\n  obj.addCallback = (callback, ...eventTypes) => {\n    eventTypes.forEach((type) => {\n      if (callbacks[type]) callbacks[type].push(callback);\n    });\n  };\n\n  obj.addKeyboardCallback = (keyCode, callback) => {\n    const events = callbacks.keyboard[keyCode];\n    events ? events.push(callback) : (callbacks.keyboard[keyCode] = [callback]);\n  };\n\n  obj.toggleComputer = () => {\n    if (computerInPlay) {\n      [player, opponent] = [inactivePlayer, inactiveOpponent];\n      computerInPlay = false;\n    } else {\n      [player, opponent] = [inactivePlayer, computer];\n      computerInPlay = true;\n    }\n    [obj.player, obj.opponent] = [player, opponent];\n  };\n\n  obj.resetGame = () => {\n    callCallbacks('preReset', [player, opponent]);\n    obj.gameInProgress = false;\n    if (computer) computer.reset();\n\n    [player, opponent].forEach((p) => clearBoards(p));\n\n    return new Promise(async (resolve) => {\n      await playerShipPlacement(player, opponent);\n      await playerShipPlacement(opponent, player);\n\n      obj.gameInProgress = true;\n      playerPlacement = {};\n      resolve();\n    });\n  };\n\n  obj.placeShipsRandomly = () => {\n    if (playerPlacement.player) randomShipPlacement(playerPlacement.player);\n  };\n\n  obj.play = async () => {\n    if (obj.gameInProgress) {\n      callCallbacks('preAttack', [player, opponent]);\n\n      const attack = await playerAttack();\n      updateDisplays(attack);\n      callCallbacks('postAttack', [player, opponent, attack]);\n\n      if (opponent.gameboard.shipCount <= 0) return endGame();\n\n      swapPlayers();\n    } else {\n      return null;\n    }\n  };\n\n  obj.playGame = async () => {\n    return (await obj.play()) || obj.playGame();\n  };\n\n  createPlayerComponents();\n\n  return obj;\n};\n\n\n//# sourceURL=webpack://odin-project-project-battleship/./lib/battleship.js?");

/***/ }),

/***/ "./lib/gameboard.js":
/*!**************************!*\
  !*** ./lib/gameboard.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Gameboard: () => (/* binding */ Gameboard)\n/* harmony export */ });\nconst Gameboard = (rows = 10, columns = 10) => {\n  let shipId = 0;\n  let ships = {};\n\n  const obj = { rows, columns };\n\n  const initializeBoard = () => {\n    shipId = 0;\n    ships = {};\n    obj.targetBoard = {};\n    obj.fleetBoard = {};\n    obj.shipPlacements = [];\n    obj.shipCount = 0;\n    obj.hitCount = 0;\n    obj.missCount = 0;\n  };\n\n  initializeBoard();\n\n  const rangeValid = (r, c) => r >= 0 && r < rows && c >= 0 && c < columns;\n\n  const adjacentPlacement = (coords, index, obj = { horizontal, vertical }) => {\n    coords.sort();\n    let [lastRow, lastCol] = coords[index - 1];\n    let [row, col] = coords[index];\n\n    let horizontalMatch =\n      row === lastRow && (lastCol + 1 === col || lastCol - 1 === col);\n    let verticalMatch =\n      col === lastCol && (lastRow + 1 === row || lastRow - 1 === row);\n\n    if (obj.horizontal || obj.vertical) {\n      if (\n        (obj.horizontal && horizontalMatch) ||\n        (obj.vertical && verticalMatch)\n      ) {\n        return obj;\n      } else {\n        return false;\n      }\n    }\n\n    obj.horizontal = horizontalMatch;\n    obj.vertical = verticalMatch;\n\n    return !obj.horizontal && !obj.vertical ? false : obj;\n  };\n\n  const placementValidation = (board, coordinates) => {\n    if (coordinates.length === 0) {\n      throw new Error('Coordinates cannot be empty');\n    }\n\n    let res, horizontal, vertical;\n    coordinates.forEach((arr, index) => {\n      if (index > 0) {\n        res = adjacentPlacement(coordinates, index, { horizontal, vertical });\n        if (!res) {\n          throw new Error(\n            'Coordinates must be vertically or horizontally adjacent'\n          );\n        }\n        horizontal = res.horizontal;\n        vertical = res.vertical;\n      }\n\n      if (board[arr]) {\n        throw new Error('Ships cannot overlap each other');\n      }\n      if (!rangeValid(arr[0], arr[1])) {\n        throw new Error('Coordinates are out of range');\n      }\n    });\n  };\n\n  obj.placeShip = (coords = [], ship = {}) => {\n    placementValidation(obj.fleetBoard, coords);\n    ships[++shipId] = ship;\n    obj.shipPlacements.push(coords);\n    obj.shipCount++;\n    coords.forEach((arr) => (obj.fleetBoard[arr] = shipId));\n    return ship;\n  };\n\n  obj.getShip = (row, column) => {\n    return ships[obj.fleetBoard[[row, column]]];\n  };\n\n  obj.receiveAttack = (row = 0, column = 0) => {\n    if (!rangeValid(row, column)) return;\n\n    const target = obj.fleetBoard[[row, column]];\n    if (target) {\n      const ship = ships[target];\n      if (ship) {\n        ship.hit();\n        obj.hitCount++;\n        if (ship.isSunk()) obj.shipCount--;\n      }\n      obj.fleetBoard[[row, column]] = true;\n      return ship || true;\n    } else {\n      if (target === undefined) obj.missCount++;\n      return (obj.fleetBoard[[row, column]] = false);\n    }\n  };\n\n  obj.makeAttack = (row = 0, column = 0, opponentBoard) => {\n    const result = opponentBoard.receiveAttack(row, column);\n\n    obj.targetBoard[[row, column]] = result ? true : false;\n    return result;\n  };\n\n  obj.allShipsSunk = () => {\n    return obj.shipCount === 0;\n  };\n\n  obj.clear = () => {\n    initializeBoard();\n  };\n\n  return obj;\n};\n\n\n//# sourceURL=webpack://odin-project-project-battleship/./lib/gameboard.js?");

/***/ }),

/***/ "./lib/gameboardDisplay.js":
/*!*********************************!*\
  !*** ./lib/gameboardDisplay.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GameboardDisplay: () => (/* binding */ GameboardDisplay)\n/* harmony export */ });\nconst GameboardDisplay = (\n  rows,\n  columns,\n  options = { keyboardTraverse: true }\n) => {\n  const obj = { locked: false };\n  const callbacks = {};\n\n  const container = document.createElement('div');\n  container.classList.value = 'gameboard';\n  container.style.gridTemplate = `repeat(${rows + 1}, 1fr) / repeat(${\n    columns + 1\n  }, 1fr)`;\n\n  if (options.keyboardTraverse) {\n    container.addEventListener('keydown', (e) => {\n      const key = e.code;\n      if (key.startsWith('Arrow') || key.startsWith('Key')) {\n        const field = document.activeElement;\n        if (field.nodeName === 'BUTTON' && field.parentElement === container) {\n          e.preventDefault();\n          let row = Number(field.dataset.field[0]);\n          let col = Number(field.dataset.field[1]);\n          if (key === 'ArrowUp' || key === 'KeyW') row--;\n          if (key === 'ArrowDown' || key === 'KeyS') row++;\n          if (key === 'ArrowLeft' || key === 'KeyA') col--;\n          if (key === 'ArrowRight' || key === 'KeyD') col++;\n\n          if (row >= 0 && row < rows && col >= 0 && col < columns) {\n            container.querySelector(`[data-field=\"${row}${col}\"]`).focus();\n          }\n        }\n      }\n    });\n  }\n\n  const appendElement = (type, callback) => {\n    const element = document.createElement(type);\n    callback(element);\n    container.appendChild(element);\n  };\n\n  const colNumber = (col) => (el) => (el.textContent = col < 1 ? '' : col);\n  const rowLetter = (row) => (el) =>\n    (el.textContent = String.fromCharCode(65 + (row % 26)));\n  const btnField = (row, col) => (el) => (el.dataset['field'] = `${row}${col}`);\n\n  const getField = (row, column) => {\n    return container.querySelector(`[data-field=\"${row}${column}\"]`);\n  };\n\n  for (let col = 0; col <= columns; col++) {\n    appendElement('span', colNumber(col));\n  }\n\n  for (let row = 0; row < rows; row++) {\n    appendElement('span', rowLetter(row));\n    for (let col = 0; col < columns; col++) {\n      appendElement('button', btnField(row, col));\n    }\n  }\n\n  obj.renderBoard = (parent = document.body, replaceExisting = true) => {\n    const previous = parent.querySelector('.gameboard');\n    if (previous && replaceExisting) previous.remove();\n    parent.appendChild(container);\n  };\n\n  obj.addCallback = (eventType, identifier, callback) => {\n    if (!callbacks[eventType]) callbacks[eventType] = {};\n\n    callbacks[eventType][identifier] = (e) => {\n      const target = e.target;\n      if (!obj.locked && target.nodeName === 'BUTTON') {\n        const [row, col] = target.dataset.field;\n        callback.call(null, Number(row), Number(col));\n      }\n    };\n\n    container.addEventListener(eventType, callbacks[eventType][identifier]);\n  };\n\n  obj.removeCallback = (eventType, identifier) => {\n    container.removeEventListener(eventType, callbacks[eventType][identifier]);\n    delete callbacks[eventType][identifier];\n  };\n\n  obj.updateField = (row, column, templateId, clazz = '') => {\n    const field = getField(row, column);\n    const template = document.getElementById(templateId);\n    if (field && template) {\n      const peg = template.content.cloneNode(true);\n      Array.from(field.children).forEach((el) => field.removeChild(el));\n      field.setAttribute('class', clazz);\n      field.appendChild(peg);\n    }\n  };\n\n  obj.highlightField = (row, column) => {\n    const field = getField(row, column);\n    if (field) field.classList.toggle('highlighted');\n  };\n\n  obj.removeHighlights = () => {\n    const fields = container.querySelectorAll('.highlighted');\n    fields.forEach((field) => field.classList.remove('highlighted'));\n  };\n\n  obj.clear = (removeCallbacks = false) => {\n    const fields = container.querySelectorAll('button');\n    fields.forEach((field) => {\n      Array.from(field.children).forEach((el) => field.removeChild(el));\n      field.setAttribute('class', '');\n    });\n\n    if (removeCallbacks) {\n      Object.keys(callbacks).forEach((eventType) => {\n        Object.keys(callbacks[eventType]).forEach((identifier) => {\n          obj.removeCallback(eventType, identifier);\n        });\n      });\n    }\n  };\n\n  return obj;\n};\n\n\n//# sourceURL=webpack://odin-project-project-battleship/./lib/gameboardDisplay.js?");

/***/ }),

/***/ "./lib/gamelog.js":
/*!************************!*\
  !*** ./lib/gamelog.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Gamelog: () => (/* binding */ Gamelog)\n/* harmony export */ });\nconst Gamelog = (clazz = '') => {\n  const obj = {};\n  const container = document.createElement('ul');\n  container.classList.value = clazz;\n\n  let messageCount = 0;\n\n  obj.renderLog = (parentElement = document.body) => {\n    parentElement.appendChild(container);\n  };\n\n  obj.addMessage = (message, numbered = true, color = '') => {\n    const li = document.createElement('li');\n    li.textContent = `${numbered ? `${++messageCount}. ` : ''}${message}`;\n    li.style.color = color;\n    container.prepend(li);\n  };\n\n  obj.clear = () => {\n    Array.from(container.children).forEach((el) => container.removeChild(el));\n    messageCount = 0;\n  };\n\n  return obj;\n};\n\n\n//# sourceURL=webpack://odin-project-project-battleship/./lib/gamelog.js?");

/***/ }),

/***/ "./lib/player.js":
/*!***********************!*\
  !*** ./lib/player.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Player: () => (/* binding */ Player)\n/* harmony export */ });\nconst Player = (name = '', gameboard = {}, computerPlayer = false) => {\n  const obj = { name, gameboard, computerPlayer };\n\n  const randomCoordinates = (length) => {\n    const row = Math.floor(Math.random() * gameboard.rows);\n    const col = Math.floor(Math.random() * gameboard.columns);\n    const index = Math.floor(Math.random() * 100);\n    const coordinates = [];\n\n    for (let i = 0; i < length; i++) {\n      coordinates.push(index < 50 ? [row + i, col] : [row, col + i]);\n    }\n\n    return coordinates;\n  };\n\n  obj.attack = (opponent, row, col) => {\n    return gameboard.makeAttack(row, col, opponent.gameboard);\n  };\n\n  obj.randomShipPlacement = (ship) => {\n    const coordinates = randomCoordinates(ship.length);\n\n    try {\n      gameboard.placeShip(coordinates, ship);\n      return coordinates;\n    } catch (error) {\n      return obj.randomShipPlacement(ship);\n    }\n  };\n\n  if (computerPlayer) {\n    let previousAttacks, nextAttacks, attackOptions;\n\n    obj.reset = () => {\n      previousAttacks = {};\n      nextAttacks = [];\n      attackOptions = [];\n\n      for (let i = 0; i < gameboard.rows; i++) {\n        for (let y = 0; y < gameboard.columns; y++) attackOptions.push([i, y]);\n      }\n    };\n\n    obj.reset();\n\n    const randomIndex = (arr) => {\n      return Math.floor(Math.random() * arr.length);\n    };\n\n    const validCoordinates = (arr) => {\n      const [row, col] = arr;\n\n      return (\n        row >= 0 &&\n        row < gameboard.rows &&\n        col >= 0 &&\n        col < gameboard.columns &&\n        !previousAttacks[arr] &&\n        !nextAttacks.some((c) => c[0] === row && c[1] === col)\n      );\n    };\n\n    const targetedAttack = (coordinates) => {\n      const [row, col] = coordinates;\n      const options = [\n        [row + 1, col],\n        [row - 1, col],\n        [row, col + 1],\n        [row, col - 1],\n      ];\n\n      options.forEach((a) => {\n        if (validCoordinates(a)) {\n          nextAttacks.push(a);\n          const idx = attackOptions.findIndex(\n            (b) => b[0] === a[0] && b[1] === a[1]\n          );\n          attackOptions.splice(idx, 1);\n        }\n      });\n    };\n\n    obj.attack = (opponent) => {\n      const options = nextAttacks.length > 0 ? nextAttacks : attackOptions;\n      if (options.length === 0) return null;\n\n      const index = randomIndex(options);\n      const coordinates = options[index];\n      options.splice(index, 1);\n      const [row, col] = coordinates;\n\n      const attackResult = gameboard.makeAttack(row, col, opponent.gameboard);\n      previousAttacks[coordinates] = true;\n      if (attackResult) targetedAttack(coordinates);\n\n      return { coordinates, attackResult };\n    };\n  }\n\n  return obj;\n};\n\n\n//# sourceURL=webpack://odin-project-project-battleship/./lib/player.js?");

/***/ }),

/***/ "./lib/ship.js":
/*!*********************!*\
  !*** ./lib/ship.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ship: () => (/* binding */ Ship)\n/* harmony export */ });\nconst Ship = (length) => {\n  function hit() {\n    this.hits++;\n  }\n\n  function isSunk() {\n    return this.hits >= this.length;\n  }\n\n  return {\n    length,\n    hits: 0,\n    hit,\n    isSunk,\n  };\n};\n\n\n//# sourceURL=webpack://odin-project-project-battleship/./lib/ship.js?");

/***/ }),

/***/ "./src/stylesheets/gameboardDisplay.css":
/*!**********************************************!*\
  !*** ./src/stylesheets/gameboardDisplay.css ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://odin-project-project-battleship/./src/stylesheets/gameboardDisplay.css?");

/***/ }),

/***/ "./src/stylesheets/index.css":
/*!***********************************!*\
  !*** ./src/stylesheets/index.css ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://odin-project-project-battleship/./src/stylesheets/index.css?");

/***/ }),

/***/ "./src/stylesheets/meyer-reset.css":
/*!*****************************************!*\
  !*** ./src/stylesheets/meyer-reset.css ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://odin-project-project-battleship/./src/stylesheets/meyer-reset.css?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylesheets_meyer_reset_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stylesheets/meyer-reset.css */ \"./src/stylesheets/meyer-reset.css\");\n/* harmony import */ var _stylesheets_index_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stylesheets/index.css */ \"./src/stylesheets/index.css\");\n/* harmony import */ var _stylesheets_gameboardDisplay_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stylesheets/gameboardDisplay.css */ \"./src/stylesheets/gameboardDisplay.css\");\n/* harmony import */ var _lib_player__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/player */ \"./lib/player.js\");\n/* harmony import */ var _lib_gameboard__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/gameboard */ \"./lib/gameboard.js\");\n/* harmony import */ var _lib_gamelog__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../lib/gamelog */ \"./lib/gamelog.js\");\n/* harmony import */ var _lib_battleship__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../lib/battleship */ \"./lib/battleship.js\");\n\n\n\n\n\n\n\n\n\nconst playerColor = (player) => {\n  if (player === playerOne) return '#5cff5c';\n  if (player === playerTwo) return '#ffff63';\n  return '#ffffff';\n};\n\nconst updateActivePlayer = (player, opponent, message) => {\n  player.container.classList.remove('hidden');\n  player.container.classList.add('activePlayer');\n  opponent.container.classList.remove('activePlayer');\n  opponent.container.classList.add('hidden');\n\n  document.querySelector('.playerName').textContent = message || player.name;\n  const playerColorElement = document.querySelector('.playerColor');\n  playerColorElement.style.backgroundColor = playerColor(player);\n};\n\nconst reset = () => {\n  const playerContainers = gameContainer.querySelectorAll('.playerContainer');\n  playerContainers.forEach((el) => {\n    el.classList.remove('winningPlayer');\n    el.remove();\n  });\n\n  gameContainer.appendChild(game.player.container);\n  gameContainer.appendChild(game.opponent.container);\n\n  updateActivePlayer(game.player, game.opponent);\n  toggleLogContainer(false);\n\n  game.resetGame().then(() => game.playGame());\n};\n\nconst setActiveShipDirection = (direction) => {\n  if (!game.gameInProgress) {\n    game.shipPlacementDirection = direction;\n    const hBtn = shipPlacementActions.querySelector('#horizontalPlacement');\n    const vBtn = shipPlacementActions.querySelector('#verticalPlacement');\n\n    if (direction === 'h') {\n      hBtn.classList.add('activeDirection');\n      vBtn.classList.remove('activeDirection');\n    } else {\n      vBtn.classList.add('activeDirection');\n      hBtn.classList.remove('activeDirection');\n    }\n  }\n};\n\nconst preShipPlacement = (player, opponent, ship) => {\n  log.addMessage(`Now placing Ship of length: ${ship.length}`);\n};\n\nconst placementError = (error) => {\n  log.addMessage(error.message, false, 'red');\n};\n\nconst preShipsPlacement = (player, opponent) => {\n  updateActivePlayer(player, opponent);\n  toggleFleetBoard(true);\n  setActiveShipDirection('h');\n  shipPlacementActions.classList.remove('hidden');\n  log.clear();\n  log.addMessage(\n    `${player.name} please place your ships`,\n    false,\n    playerColor(player)\n  );\n};\n\nconst postShipsPlacement = () => {\n  toggleFleetBoard(true);\n  shipPlacementActions.classList.add('hidden');\n  log.clear();\n};\n\nconst preAttack = (player, opponent) => {\n  updateActivePlayer(player, opponent);\n};\n\nconst postAttack = (player, opponent, attack) => {\n  const [row, col] = attack.coordinates;\n  const attackResult = attack.attackResult;\n  const field = `${String.fromCharCode(65 + row)}${col + 1}`;\n  const attackType = attackResult ? 'Hit' : 'Miss';\n\n  log.addMessage(\n    `Attack from ${player.name} at ${field} resulted in ${attackType}`,\n    true,\n    playerColor(player)\n  );\n\n  if (typeof attackResult === 'object' && attackResult.isSunk()) {\n    const remainingShips = opponent.gameboard.shipCount;\n    const messageOne = `${player.name} has sunk ship of size ${attackResult.length}.`;\n    const messageTwo = `${opponent.name} has ${remainingShips} remaining ships.`;\n\n    log.addMessage(messageOne, false, '#00dada');\n    log.addMessage(messageTwo, false, '#00dada');\n  }\n\n  if (!player.computerPlayer && !opponent.computerPlayer) {\n    toggleFleetBoard(true);\n  }\n};\n\nconst postGame = (player, opponent) => {\n  const message = `${player.name} has won the game!`;\n  log.addMessage(message, false);\n  toggleLogContainer(true);\n  updateActivePlayer(player, opponent, message);\n\n  fleetToggle.checked = false;\n\n  gameContainer.querySelectorAll('.fleetBoard').forEach((el) => {\n    el.classList.remove('hidden');\n  });\n\n  gameContainer.insertBefore(player.container, opponent.container);\n  player.container.scrollIntoView({ behavior: 'smooth' });\n\n  player.container.classList.add('winningPlayer');\n  opponent.container.classList.remove('hidden');\n};\n\nconst placementActions = (ev) => {\n  const target = ev.target;\n  const direction = target.dataset.direction;\n  if (direction) {\n    game.shipPlacementDirection = direction;\n    setActiveShipDirection(direction);\n  }\n  if (target.id === 'randomPlacement') game.placeShipsRandomly();\n};\n\nconst toggleComputer = () => {\n  game.toggleComputer();\n  reset();\n};\n\nconst toggleComputerViaKey = () => {\n  computerToggle.checked = !computerToggle.checked;\n  toggleComputer();\n};\n\nconst toggleVisibility = (toggle, element, forceVisibility) => {\n  if (forceVisibility === true || forceVisibility === false) {\n    toggle.checked = forceVisibility;\n    forceVisibility\n      ? element.classList.add('hidden')\n      : element.classList.remove('hidden');\n  } else toggle.checked = element.classList.toggle('hidden');\n};\n\nconst toggleLogContainer = (forceVisibility) => {\n  toggleVisibility(logToggle, logContainer, forceVisibility);\n};\n\nconst toggleFleetBoard = (forceVisibility) => {\n  const fleetBoard = document.querySelector('.activePlayer .fleetBoard');\n  toggleVisibility(fleetToggle, fleetBoard, forceVisibility);\n};\n\nconst resetButton = document.getElementById('resetGame');\nconst computerToggle = document.getElementById('computerPlay');\nconst logToggle = document.getElementById('hideLog');\nconst fleetToggle = document.getElementById('fleetToggle');\n\nconst shipPlacementActions = document.querySelector('.shipPlacementActions');\nconst logContainer = document.querySelector('.logContainer');\nconst gameContainer = document.querySelector('.gameContainer');\n\nconst playerOne = (0,_lib_player__WEBPACK_IMPORTED_MODULE_3__.Player)('Player One', (0,_lib_gameboard__WEBPACK_IMPORTED_MODULE_4__.Gameboard)(10, 10));\nconst playerTwo = (0,_lib_player__WEBPACK_IMPORTED_MODULE_3__.Player)('Player Two', (0,_lib_gameboard__WEBPACK_IMPORTED_MODULE_4__.Gameboard)(10, 10));\nconst computer = (0,_lib_player__WEBPACK_IMPORTED_MODULE_3__.Player)('Computer', (0,_lib_gameboard__WEBPACK_IMPORTED_MODULE_4__.Gameboard)(10, 10), true);\nconst game = (0,_lib_battleship__WEBPACK_IMPORTED_MODULE_6__.Battleship)(playerOne, playerTwo, computer);\nconst log = (0,_lib_gamelog__WEBPACK_IMPORTED_MODULE_5__.Gamelog)('gameLog');\n\nlog.renderLog(logContainer);\n\ngame.addCallback(preShipPlacement, 'preShipPlacement');\ngame.addCallback(placementError, 'placementError');\ngame.addCallback(preShipsPlacement, 'preShipsPlacement');\ngame.addCallback(postShipsPlacement, 'postShipsPlacement');\ngame.addCallback(preAttack, 'preAttack');\ngame.addCallback(postAttack, 'postAttack');\ngame.addCallback(postGame, 'postGame');\n\nshipPlacementActions.addEventListener('click', placementActions);\nresetButton.addEventListener('click', reset);\ncomputerToggle.addEventListener('change', toggleComputer);\nlogToggle.addEventListener('change', toggleLogContainer);\nfleetToggle.addEventListener('change', toggleFleetBoard);\n\ngame.addKeyboardCallback('KeyR', reset);\ngame.addKeyboardCallback('KeyC', toggleComputerViaKey);\ngame.addKeyboardCallback('KeyL', toggleLogContainer);\ngame.addKeyboardCallback('KeyF', toggleFleetBoard);\ngame.addKeyboardCallback('KeyH', () => setActiveShipDirection('h'));\ngame.addKeyboardCallback('KeyV', () => setActiveShipDirection('v'));\n\nreset();\n\n\n//# sourceURL=webpack://odin-project-project-battleship/./src/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;